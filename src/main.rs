//! This generates witnesses to test circom artifacts in the `circuits` directory.

#![feature(trivial_bounds)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(non_snake_case)]
#![allow(clippy::clone_on_copy)]
#![allow(unused_mut)]

use std::io;

use ark_circom::CircomBuilder;
use ark_ec::pairing::Pairing;

mod proof;
mod witness;

/// Circom compilation artifacts
/// Must compile circom artifacts first if these aren't found.
const SIV_WTNS: &str = "./build/gcm_siv_dec_2_keys_test_js/gcm_siv_dec_2_keys_test.wasm";
const SIV_R1CS: &str = "./build/gcm_siv_dec_2_keys_test.r1cs";
const AES_256_CRT_WTNS: &str = "./build/aes_256_ctr_test_js/aes_256_ctr_test.wasm";
const AES_256_CRT_R1CS: &str = "./build/aes_256_ctr_test.r1cs";

pub type AAD = [u8; 5];
pub type Nonce = [u8; 12];

/// Witness bytes generated by this binary
pub struct Witness {
    pub key: Vec<u8>,
    pub iv:  Vec<u8>,
    pub ct:  Vec<u8>,
    pub pt:  Vec<u8>,
}

// TODO(TK 2024-08-06): move these to tests
#[tokio::main]
async fn main() -> io::Result<()> {
    // aes_gcm_siv_test().await?;

    // aes_256ctr_test().await?;
    Ok(())
}

// TODO(TK 2024-08-06): refactor; move util methods to utils
// TODO(TK 2024-08-06): test with test vectors at bottom of rfc 8452
//
/// construct the nonce from the `iv` and `seq` as specified in RFC 8452
/// https://www.rfc-editor.org/rfc/rfc8452
pub fn make_nonce(iv: [u8; 12], seq: u64) -> Nonce {
    let mut nonce = [0u8; 12];
    nonce[4..].copy_from_slice(&seq.to_be_bytes());

    nonce.iter_mut().zip(iv).for_each(|(nonce, iv)| {
        *nonce ^= iv;
    });

    nonce
}

fn make_tls13_aad(len: usize) -> AAD {
    [
        0x17, // ContentType::ApplicationData
        0x3,  // ProtocolVersion (major)
        0x3,  // ProtocolVersion (minor)
        (len >> 8) as u8,
        len as u8,
    ]
}

// TODO(TK 2024-08-06): @devloper, document
fn push_bytes_as_bits<T: Pairing>(
    mut builder: CircomBuilder<T>,
    field: &str,
    bytes: &[u8],
) -> CircomBuilder<T> {
    for byte in bytes {
        for i in 0..8 {
            let bit = (byte >> (7 - i)) & 1;
            builder.push_input(field, bit as u64);
        }
    }

    builder
}

#[cfg(test)]
mod tests {
    use super::*;

    // Test the AES-GCM-SIV circuit (from electron labs)
    #[tokio::test]
    async fn test_aes_gcm_siv() -> io::Result<()> {
        // generate witness
        let mut witness = witness::aes_witnesses(witness::CipherMode::GcmSiv);

        // log one of them
        println!(
            "proof gen: key={:?}, iv={:?}, ct={:?}, pt={:?}",
            witness.key, witness.iv, witness.ct, witness.pt
        );

        // TODO(TK 2024-08-06): replace hackz with documented methods
        //  hackz for 128 bit iv, Ask Tracy about this
        witness.iv.extend_from_slice(&[0, 0, 0, 0]);

        // generate proof
        proof::gen_proof_aes_gcm_siv(&witness, SIV_WTNS, SIV_R1CS);
        Ok(())
    }
}
